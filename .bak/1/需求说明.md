编写一个通过自然语言生成代码的服务系统。

简短说明:
路由1: /v1/chat/completions 通过该路由接收用户的自然语言输入，并返回生成 workflow: {  projectName:"",description:"",pages:[], workflows:[] } 类似这种结构化的响应，然后前端根据这个结构化数据来生成一个项目结构和页面流程图。
路由2: /v1/generate-code 通过该路由接收 pages 要生成的页面列表并调用模型生成代码。
路由3：/platform/project 通过改路由查找当前已有的项目列表
路由4：/platform/initial 通过该路由做些项目初始化工作
路由5: /platform/project/upload/pages/img 通过该路由接收前端上传的图片文件，并保存到服务器
路由6：/platform/project/design/pages 通过该路由查找当前项目下所有页面列表并返回
路由7：/platform/project/design/workflow/detail 通过该路由获取工作流详情
路由8: /platform/project/export 通过该路由导出项目代码
路由9：/platform/project/duplicate 通过该路由复制一个已有项目
路由10: /platform/project/rename 通过该路由重命名一个项目
路由11: /platform/project/delete 通过该路由删除一个项目
路由12：/platform/project/page/error 通过该路由页面报错后重新生成
路由13: /v1/generate-recode 通过改路由重新生成页面代码
路由14: /v1/regenerate-code 通过该路由重新生成所有页面
路由15：/v1/update-workflow 通过该路由更新工作流

详细说明：
1. workflow.json 数据结构如下 
```js
{
    content:{ 
        projectName:"",
        description:"",
        pages:[],
        workflows:[],
        status:""
        error:null,
        errorMessage:"",
    },
    createAt:"",
    target:"",
    resolution:"",
}
```
2. 所有路由都是基于http-server 原生开发，所有请求方法都是POST, 需要使用esmodule, 不要使用require写法, 不能使用ts,入口逻辑如下：
```js
 
    function startServer(port, attempts) {
        const server = http.createServer(async (req, res) => {
            const { method, url: reqUrl } = req;
            const parsedUrl = url.parse(reqUrl, true);
            const pathname = parsedUrl.pathname;
        // 设置CORS响应头
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS, GET');
            res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    
            // 处理预检请求(OPTIONS)
            if (method === 'OPTIONS') {
                res.writeHead(204);
                return res.end();
            }


            // 处理图片请求
            if (pathname.startsWith('/assets/') && pathname.endsWith('.png')) {
                const homeDir = await utilsService.getHzuxRoot('ai-ux');
                const filePath = path.join(homeDir, pathname);
                fs.readFile(filePath, (err, data) => {
                    if (err) {
                        res.writeHead(404);
                        return res.end('Not Found');
                    }
                    
                    res.writeHead(200, { 
                        'Content-Type': 'image/png',
                        'Cache-Control': 'public, max-age=31536000' // 设置长期缓存
                    });
                    res.end(data);
                });
                return;
            }

            // 收集请求体数据
            let body = [];
            req.on('data', (chunk) => {
                body.push(chunk);
            }).on('end', () => {
                body = Buffer.concat(body).toString();
                let requestData;
                try {
                    requestData = body ? JSON.parse(body) : {};
                } catch (e) {
                    res.writeHead(400, { 'Content-Type': 'application/json' });
                    return res.end(JSON.stringify(utilsService.returnData({ errorCode: ErrorCodes.FILE_IO_ERROR, errorMessage: 'Invalid JSON' })));
                }
    
                // 路由处理
                switch (pathname) {
                    case '/v1/chat/completions':
                        handleChatCompletions(req, res, requestData);
                        break;
                    case '/v1/update-workflow':
                        handleUpdateWorkflow(req, res, requestData);
                        break;
                    case '/v1/regenerate-code':
                        handleRegenerateCode(req, res, requestData);
                        break;
                    case '/v1/generate-code':
                        handleGenerateCode(req, res, requestData);
                        break;
                    case '/v1/generate-recode':
                        handleGenerateRecode(req, res, requestData);
                        break;
                    case '/platform/project/upload/pages/img':
                        handleUploadPagesImg(req, res, requestData);
                        break;
                    case '/platform/project/design/workflow/detail':
                        handleWorkflowDetail(req, res, requestData);
                        break;
                    case '/platform/project/design/pages':
                        handleDesignPages(req, res, requestData);
                        break;
                    case '/platform/project':
                        handlePlatformProject(req, res, requestData);
                        break;
                    case '/platform/initial': 
                        handleInitial(req, res, requestData);
                        break;
                    case '/platform/project/page/error': 
                        handlePageError(req, res, requestData);
                        break;
                    case '/platform/project/delete': 
                        handleDeleteProject(req, res, requestData);
                        break;
                    case '/platform/project/rename': 
                        handleRenameProject(req, res, requestData);
                        break;
                    case '/platform/project/duplicate': 
                        handleDuplicateProject(req, res, requestData);
                        break;
                    case '/platform/project/export':
                        handleExportProject(req, res, requestData);
                        break;
                    default:
                        res.writeHead(404, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Not Found' }));
                }
            });
        });
    
        // 启动服务器
    
        server.listen(port, () => {
            console.log(`Server running on port ${port}`);
        });
        server.on('error', (err) => {
            if (err.code === 'EADDRINUSE' && attempts > 0) {
                console.log(`Port ${port} is already in use. Trying port ${port + 1}...`);
              } else {
                console.error('Server error:', err);
              }
        })
    }

```
全局路径说明
```js
const homeDir = await utilsService.getHzuxRoot('ai-ux'); 
const clientDir = path.join(homeDir, 'client'); // 生成的vue文件插入热更新地方
const componentDir = path.join(clientDir, 'src', 'components'); // 生成的vue组文件插入地方
const dynamicDir = path.join(clientDir, 'src', 'dynamic'); // 生成的vue文件插入地方
const projectDir = await utilsService.getHzuxRoot();  // 项目副本存储地方
```

/v1/chat/completions 入参: 
```js
  const {
    prompt,
    projectId: reqProjectId,
    target = "web",
    resolution = "1920 * 1080",
    model = "qwen-coder"
  } = data;

  res.writeHead(200, { "Content-Type": "application/json" });
  // async todo...
  res.end(
    JSON.stringify(
      utilsService.returnData({
        ...data,
        status: "success",
        message: "接口调用成功",
      })
    )
  );
```
- 调用此路由直接返回结果
- 异步在后台调用模型生成workflow数据, 模型返回数据后将其写入到{projectDir}/{reqProjectId}/{version}/data/workflow.json, version 这里的version可以从1开始，也可以调用 utilsService.createVersion() 接口获取, 它会查看当前${projectDir}/${reqProjectId}目录下最大的version+1，若目录不存在则返回1
- workflow.json 是一个JSON.stringify({  projectName:"",description:"",pages:[], workflows:[] }) 模型会返回这个，你需要手动添加 status: "success", error:null, errorMessage:"", 如果接口调用失败，你需要手动创建一个空的workflow.json文件并写入空的JSON结构 JSON.stringify({  projectName:"",description:"",pages:[], workflows:[]，status: "error", error, errorMessage:"模型调用失败，请重试" })  error是一个错误对象。
- 调用模型接口生成工作流 messages， ANALYSIS_SYSTEM_PROMPT可以查prompt.js
```js

  const messages = [
    { role: "system", content: ANALYSIS_SYSTEM_PROMPT },
    { role: "user", content: prompt },
  ];
```

/v1/generate-code 入参：
```js
const {
    pages, // 页面列表
    checkedNodes, // 要生成的页面列表
    projectId, // 所在项目id
    target = "web", // 目标平台
    resolution = "1920 * 1080",
    workflows, // workflow
    model, // 选择的模型
  } = data;
res.writeHead(200, { "Content-Type": "application/json" });
// todo...
res.end(
    JSON.stringify(
      utilsService.returnData({
        status: "success",
        message: "接口调用成功",
      })
    )
);
```
- 调用此路由直接返回结果
- 异步在后台并行调用模型生成页面，生成完页面后要把生成的结果写入到一个文件里命名为 {pageId}.vue 存放在{projectDir}/{projectId}/{version}/code/*, 于此同时要把生成的页面copy到 {dynamicDir} 中
- 在生成页面时可以在后台把pages 和 workflows更新 {projectDir}/{projectId}/{version}/data/workflow.json, 这里的version可以从1开始，也可以调用 utilsService.getLastestVersion(root) 接口获取， root = {projectDir}/{projectId}
- 调用模型接口生成页面 messages, SYSTEM_PROMPT 可以查prompt.js, globalCompPrompt 是一些全局组件
```js

const basePrompt = `
    页面名称：${page.name}
    页面描述：${page.description}
    页面导航：${JSON.stringify(page.navigationList)}
    任务描述：基于我输入的页面描述、页面导航、设备类型等信息帮我进行页面设计和开发工作
    `;
let systemPrompt = SYSTEM_PROMPT;
systemPrompt = systemPrompt.replace("{globalComponents}", globalCompPrompt);
systemPrompt = systemPrompt.replace("{stype}", "");
const messages = [
    { role: "system", content: systemPrompt },
    { role: "user", content: basePrompt },
];
```
- 生成页面后，你需要把当前页面对应的状态更新成done，当页面生成失败或者错误状态需要更新成error，你需要更新{projectDir}/{projectId}/{version}/data/workflow.json 里 对应pages 里的 page.status，这里的version可以从1开始，也可以调用 utilsService.getLastestVersion(root) 接口获取， root = {projectDir}/{projectId}
- 你需要准备一个错误队列，将生成失败的页面加入错误队列，等其他页面生成完毕后，再重新执行错误队列中的任务


/v1/regenerate-code 入参：
```js
const { 
        pages, // 要生成的页面列表
        projectId,
        model
} = data;
res.writeHead(200, { "Content-Type": "application/json" });
// todo...
res.end(
    JSON.stringify(
      utilsService.returnData({
        status: "success",
        message: "接口调用成功",
      })
    )
);
```
- 调用此路由直接返回结果
- 异步在后台并行调用模型生成页面，生成完页面后要把生成的结果写入到一个文件里命名为 {pageId}.vue 存放在{projectDir}/{projectId}/{version}/code/*, 于此同时要把生成的页面copy到 {dynamicDir} 中，这里的version可以从1开始，也可以调用 utilsService.getLastestVersion(root) 接口获取， root = {projectDir}/{projectId}
- 调用模型接口生成页面 messages, SYSTEM_PROMPT 可以查prompt.js, globalCompPrompt 是一些全局组件
```js

const basePrompt = `
    页面名称：${page.name}
    页面描述：${page.description}
    页面导航：${JSON.stringify(page.navigationList)}
    任务描述：基于我输入的页面描述、页面导航、设备类型等信息帮我进行页面设计和开发工作
    `;
let systemPrompt = SYSTEM_PROMPT;
systemPrompt = systemPrompt.replace("{globalComponents}", globalCompPrompt);
systemPrompt = systemPrompt.replace("{stype}", "");
const messages = [
    { role: "system", content: systemPrompt },
    { role: "user", content: basePrompt },
];
```
- 生成页面后，你需要把当前页面对应的状态更新成done，当页面生成失败或者错误状态需要更新成error，你需要更新{projectDir}/{projectId}/{version}/data/workflow.json 里 对应pages 里的 page.status，这里的version可以从1开始，也可以调用 utilsService.getLastestVersion(root) 接口获取， root = {projectDir}/{projectId}
- 你需要准备一个错误队列，将生成失败的页面加入错误队列，等其他页面生成完毕后，再重新执行错误队列中的任务


/v1/generate-recode 入参：
```js
const {
    projectId, // 当前项目id
    pageId, // 页面id，
    name, // 页面名称
    description, // 页面描述
    status = "generating", // 页面状态
    navigationList, // 页面导航栏列表
    target = "web",
    resolution = "1920 * 1080",
    model = "qwen-coder",
} = data;
res.writeHead(200, { "Content-Type": "application/json" });
// todo...
res.end(
    JSON.stringify(
      utilsService.returnData({
        status: "success",
        message: "接口调用成功",
      })
    )
);
```
- 调用此路由直接返回结果
- 异步在后台调用模型生成页面，生成完页面后要把生成的结果写入到一个文件里命名为 {pageId}.vue 存放在{projectDir}/{projectId}/{version}/code/*, 于此同时要把生成的页面copy到 {dynamicDir} 中，这里的version可以从1开始，也可以调用 utilsService.getLastestVersion(root) 接口获取， root = {projectDir}/{projectId}
- 调用模型接口生成页面 messages, SYSTEM_PROMPT 可以查prompt.js, globalCompPrompt 是一些全局组件
```js

const basePrompt = `
    页面名称：${page.name}
    页面描述：${page.description}
    页面导航：${JSON.stringify(page.navigationList)}
    任务描述：基于我输入的页面描述、页面导航、设备类型等信息帮我进行页面设计和开发工作
    `;
let systemPrompt = SYSTEM_PROMPT;
systemPrompt = systemPrompt.replace("{globalComponents}", globalCompPrompt);
systemPrompt = systemPrompt.replace("{stype}", "");
const messages = [
    { role: "system", content: systemPrompt },
    { role: "user", content: basePrompt },
];
```
- 生成页面后，你需要把当前页面对应的状态更新成done，当页面生成失败或者错误状态需要更新成error，你需要更新{projectDir}/{projectId}/{version}/data/workflow.json 里 对应pages 里的 page.status，这里的version可以从1开始，也可以调用 utilsService.getLastestVersion(root) 接口获取， root = {projectDir}/{projectId}
- 你需要准备一个错误队列，将生成失败的页面加入错误队列，等其他页面生成完毕后，再重新执行错误队列中的任务


/v1/update-workflow 入参：
```js
const { 
     pages,  // 页面列表
     projectId, // 项目id
     workflows  // workflows列表
} = data;
res.writeHead(200, { "Content-Type": "application/json" });
// todo...
res.end(
    JSON.stringify(
      utilsService.returnData({
        status: "success",
        message: "接口调用成功",
      })
    )
);
```
- 调用此路由直接返回结果
- 异步在后台更新{projectDir}/{projectId}/{version}/data/workflow.json, 这里的version可以从1开始，也可以调用 utilsService.getLastestVersion(root) 接口获取， root = {projectDir}/{projectId}


/platform/project/design/workflow/detail 入参：
```js
const { 
     projectId, // 项目id
} = data;
res.writeHead(200, { "Content-Type": "application/json" });
// todo...
const workflowData = await ...
res.end(
    JSON.stringify(
      utilsService.returnData({
        status: "success",
        ...workflowData,
        message: "接口调用成功",
      })
    )
);
```
- 调用文件读取 {projectDir}/{projectId}/{version}/data/workflow.json, 这里的version可以从1开始，也可以调用 utilsService.getLastestVersion(root) 接口获取， root = {projectDir}/{projectId}


/platform/project/upload/pages/img 入参：
```js
const { 
    projectId, // 项目id
    pageId: pageName, // 页面id
    imgUrl: base64Data  // 当前页面base64图片数据
} = data;

res.writeHead(200, { "Content-Type": "application/json" });
// todo...
res.end(
    JSON.stringify(
      utilsService.returnData({
        status: "success",
        message: "接口调用成功",
      })
    )
);
```
- 将base64Data 写入到 {projectDir}/{projectId}/{version}/cover/{pageName}.png
- 更新workflow 里 pages 里对应page的
```js
 const content = JSON.parse(workflow.content);
    // 更新指定页面的imgUrl
    for (const page of content.pages) {
      if (page.pageId === pageId) {
        page.imgUrl = `/assets/${projectId}/1/${pageId}.png`;
        break; // 找到目标页面后可以提前退出循环
      }
    }

    // 直接操作content对象，而不是workflow.content
    content.imgUrl = content.pages[0].imgUrl;
    workflow.content = JSON.stringify(content);
```


/platform/project/design/pages 入参：
```js
const { 
    projectId, // 项目id
} = data;

res.writeHead(200, { "Content-Type": "application/json" });
// todo...
const replyData = await 
res.end(
    JSON.stringify(
      utilsService.returnData({
        status: "success",
        list:replyData，
        message: "接口调用成功",
      })
    )
);
```
- 拿projectId从workflow.json查出对应的pages并返回


/platform/project ：
```js

 const { keyword, page = 1, sort, pageSize = 10 } = data;
  const map = await projectService.getProjectMap();

  // 为每个项目获取第一个页面的imgUrl
  let projects = await Promise.all(
    Object.entries(map).map(async ([id, info]) => {
      // 获取workflow pages
      const pages = await getWorkflowPages(id);
      let imgUrl = null;
      // 如果有pages且第一个page有imgUrl,则使用它
      if (pages && pages.length > 0 && pages[0].imgUrl) {
        imgUrl = pages[0].imgUrl;
      }
      return {
        projectId: id,
        ...info,
        imgUrl,
      };
    })
  );

  if (keyword) {
    projects = projects.filter((p) => p.projectName?.includes(keyword));
  }

  // 按时间降序排序
  projects.sort((a, b) => {
    const timeA = a.createAt || a.projectId;
    const timeB = b.createAt || b.projectId;
    return new Date(timeB) - new Date(timeA);
  });

  const start = (page - 1) * pageSize;
  const respData = projects.slice(start, start + pageSize);

  res.writeHead(200, { "Content-Type": "application/json" });
  res.end(
    JSON.stringify(
      utilsService.returnData({
        list: respData,
        total: projects.length,
        message: "Platform project processed",
      })
    )
  );
```
- 通过project-map 把当前项目查出来按时间倒叙排序查询出来


其余接口不重要 写个函数站位就好。

最后注意事项：
/v1/chat/completions 调用这个接口时  
你需要初始化
{projectDir}/{projectId}/{version}/code
{projectDir}/{projectId}/{version}/data
{projectDir}/{projectId}/{version}/cover
{projectDir}/{projectId}/{version}/components

并填充
{projectDir}/{projectId}/{version}/data/workflow.json 

```js
{
    content:{ 
        projectName:"",
        description:"",
        pages:[],
        workflows:[],
        status:""
        error:null,
        errorMessage:"",
    },
    createAt:"",
    target:"",
    resolution:"",
}
```
你还需要 更新 {projectDir}/project-map.json 

如果有则更新，如果没有则创建
```JSON
{
  "{projectId}": {
    "createAt": "",
    "status": "pending",
    "projectName": "",
    "target": "web",
    "imgUrl": "",
    "resolution": "",
    "path": "{projectDir}/{projectId}"
  },
}
```

你需要创建 CodeGeneratorAgent 并给它配备 tools: [read_file,write_file,file_list], 你还需要创建 WorkFlowAgent 并给它配备 tools: [read_file,write_file,file_list]
其余随意发挥吧。
