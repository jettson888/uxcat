---
trigger: always_on
---
重要规则:
1. 忽略.bak文件夹内容.bak是存储项目代码副本.
2. 忽略程序说明文档、server/程序说明说明文档。

需求: 自然语言转Vue2代码
1. client是实时代码运行工程,用于server调用完llm生成完代码并copy到client实现实时渲染.
2. server工程是提供服务的工程,服务是原生http server服务,因为后续这个服务需要被嵌入到electron中所以希望轻量.
3. skeleton是提供用于与用户交互的工程,在这个工程里主要页面有3个 1.home/index.vue (需求输入页面) 2.flowchart/index.vue (流程图展示编辑选择页面) 3.product/index.vue (代码生成渲染后的预览页面)

整体交互流程:
交互1:
在skeleton工程home页面中用户可以输入如: 生成一个对公访客页面, 点击后随即跳转到 flow页面 (前端生成随机projectId以query形式带到flow页面)。flow页面通过projectId调用轮询接口获取当前project的页面数据并展示,用户可能会编辑流程图,新增页面节点,删除页面节点,用户可以勾选页面节点并点击生成代码随即跳转到production页面。在product页面会有轮询接口查询页面列表。

交互2:
在skeleton工程home页面输入框下面会有一列项目列表的展示,展示着所有生成的项目,包括生成中的项目和以生成的项目。项目创建时机是当用户在home首页通过输入框输入完需求点击提交后项目立即创建,项目的id是前端生成传给服务端,项目列表展示的项目信息是项目首页快照封面url、项目名称、项目创建时间。当点击项目拿着projectId 跳转到 flow页此后流程跟交互1一样。

交互3:
在skeleton工程的product页面会有重新生成所有页面和重新生成单个页面,重新生成所有页面是用户可以把页面列表剩余未生成的页面做一个调用接口进行生成,重新生成单个页面是用户可以更改某个不喜欢的页面,可以修改某个页面的页面名称以及页面描述进行重新生成。


注意: 
- 在flow页用户可能会勾选多个页面节点生成页面此时server会涉及到大量的并发请求所以要搞个并发控制,和请求随机抖动,以及超时并发下的超时控制。
- 每个页面都需要有状态,这个状态一开始是pending、生成中是generating、生成失败是error、生成成功是done
- 初始化路由时机,为了避免生成中以及用户预览生成好的页面闪屏问题,因此初始化路由目前是提前到了flow数据出来后,拿着flow下的pages 便利出page id以这个提前写入到client router index中,但因此用户在flow页面 新增节点和删除节点 需要把client中的页面与路由做同步操作。
- 因为不涉及数据库,所以产生的数据均需要以文件存储的方式记录下来。
- 在交互1用户输入完需求点击提交立即来到了flow页轮询,此时server /v1/chat/completions 不能阻塞需要立即返回状态
- 在生成代码时/v1/generate-code, skeleton从flow页勾选要生成的页面节点来到product页面展示页,会有一个pages列表 这个也是轮询调用,此时模型还未生成好页面代码也许模型会超时等等,因为前端需要提前展示所以在点击生成页面时 前端会把status改成 generating, 此时需要服务端把对应的文件page status也改成相关状态
- 在模型超时和模型生成页面代码的过程中,生成的代码文件和flow本地磁盘写入的page status一致性问题需要注意。
- 用户可能在生成页面过程中关闭了程序此时相关的page status 需要结合实际情况判断。
- 对外调用接口1./v1/chat/completions 调用llm 2./llm/knowledge_chat/invoke 调用知识库 这两个接口都需要添加超时控制。在生成代码前,需要调用llm生成页面都需要用到哪些组件,调用知识库把相关组件信息查出来,再次调用llm

优化:
- 在重新生成页面和生成页面的动作上是否可以统一调用一个接口,因为生成页面本质上就是用提示词给到llm, 是否可以统一用一个全局的生成页面的任务队列管理。
- 给页面新增一个timeout超时状态
